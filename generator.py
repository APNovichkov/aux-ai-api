from music21 import converter, instrument, note, chord, stream
import numpy as np
from uuid import uuid1
import os
import subprocess

SCRATCH_DIR = "scratch"
MP3_DIR = "mp3_files"

class Generator():
    def __init__(self, composer):
        self.composer = composer

        if not os.path.exists(SCRATCH_DIR):
            os.mkdir(SCRATCH_DIR)

    def generate_song(self, num_notes=100):
        """Generate song with given # of notes and return path to resulting midi file"""

        # Initialize composer's model if not yet initialized and import it into the generator
        if not self.composer.get_model():
            self.composer.init_model()

        # Get the model
        model = self.composer.get_model()

        # Use it to generate notes
        notes = self._generate_notes(model, num_notes)

        # Write midi file from notes array and get its filepath
        midi_fp = self._convert_to_midi_file(notes)

        # Convert midi to mp3
        mp3_fp = self._convert_midi_to_mp3(midi_fp)

        return mp3_fp, os.path.basename(mp3_fp).split('.')[0]

    def _generate_notes(self, model, num_notes):
        """Return Generated Notes"""

        start = np.random.randint(0, len(self.composer.get_network_input()) - 1)
        print(f"start: {start}")

        int_to_note = dict((number, note) for number, note in enumerate(self.composer.get_pitch_names()))

        pattern = self.composer.get_network_input()[start]
        prediction_output = []

        # Generate n notes
        notes_to_generate = int(num_notes)
        for note_index in range(notes_to_generate):
            prediction_input = np.reshape(pattern, (1, len(pattern), 1))
            prediction = model.predict(prediction_input, verbose=0)[0]

            prediction_index = np.argmax(prediction)

            prediction_note = int_to_note[prediction_index]
            prediction_output.append(prediction_note)
            prediction_result = prediction_index / float(self.composer.get_n_vocab()[0])

            pattern = np.append(pattern, prediction_result)
            pattern = pattern[1:len(pattern)]

        print(f"Output notes: {prediction_output}")
        return prediction_output

    def _convert_to_midi_file(self, notes):
        """Convert encoded input notes array into a midi file"""

        offset = 0
        output_notes = []
        # create note and chord objects based on the values generated by the model
        for pattern in notes:
            # pattern is a chord
            if (',' in pattern) or pattern.isdigit():
                pitch = pattern.split(":")[0]
                duration = pattern.split(":")[1]
                notes_in_chord = pitch.split(',')
                chord_notes = []
                for current_note in notes_in_chord:
                    new_note = note.Note(int(current_note))
                    new_note.storedInstrument = instrument.AltoSaxophone()
                    chord_notes.append(new_note)
                new_chord = chord.Chord(chord_notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
            # pattern is a note
            elif "rest" in pattern:
                duration = pattern.split(":")[1]
                new_note = note.Rest()
                new_note.offset = offset

                output_notes.append(new_note)
            else:
                pitch = pattern.split(":")[0]
                duration = pattern.split(":")[1]

                try:
                    new_note = note.Note(pitch)
                except:
                    continue
                new_note.offset = offset
                new_note.storedInstrument = instrument.AltoSaxophone()
                output_notes.append(new_note)
            # increase offset each iteration so that notes do not stack

            if '/' in duration:
                duration = float(int(duration.split('/')[0]) / int(duration.split('/')[1]))

            offset += float(duration)

        midi_stream = stream.Stream(output_notes)
        output_fp = os.path.join(SCRATCH_DIR, f"{uuid1().hex}_{self.composer.get_name()}.midi")
        midi_stream.write('midi', fp=output_fp)
        return output_fp

    def _convert_midi_to_mp3(self, midi_fp):
        """Convert midi to mp3"""

        if not os.path.exists(MP3_DIR):
            os.mkdir(MP3_DIR)

        mp3_fp = os.path.join(MP3_DIR, f'{uuid1().hex}.mp3')

        command = f"timidity {midi_fp} -Ow -o - | ffmpeg -y -f wav -i - {mp3_fp}"
        print(f"Running command: {command}")

        subprocess.call(command, shell=True)

        print(f"Done converting file")

        return mp3_fp

